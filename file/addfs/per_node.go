package addfs

import (
	"context"

	"github.com/grailbio/base/file/fsnode"
)

type (
	// PerNodeFunc computes nodes to add to a directory tree, for example to present alternate views
	// of raw data, expand archive files, etc. It operates on a single node at a time. If it returns
	// any "addition" nodes, ApplyPerNodeFuncs will place them under a sibling directory called
	// "...". For example, suppose we have an input directory:
	//   parent/
	//   └─dir1/
	//     ├─fileA
	//     ├─fileB
	//     └─dir2/
	// and we call ApplyPerNodeFuncs(parent/, ourFns). The resulting directory tree will be
	//   parent/
	//   ├─.../
	//   │ └─dir1/
	//   │   └─[ nodes returned by PerNodeFunc.Apply(_, dir1/) for all ourFns ]
	//   └─dir1/
	//     ├─.../
	//     │ ├─fileA/
	//     │ │ └─[ nodes returned by PerNodeFunc.Apply(_, fileA) for all ourFns ]
	//     │ ├─fileB/
	//     │ │ └─[ nodes returned by PerNodeFunc.Apply(_, fileB) for all ourFns ]
	//     │ └─dir2/
	//     │   └─[ nodes returned by PerNodeFunc.Apply(_, dir2/) for all ourFns ]
	//     ├─fileA
	//     ├─fileB
	//     └─dir2/
	//       └─.../
	// Users browsing this resulting tree can work with just the original files and ourFns won't
	// be invoked. However, they can also navigate into any of the .../s if interested and then
	// use the additional views generated by ourFns. If they're interested in our_view for
	// /path/to/a/file, they just need to prepend .../, like /path/to/a/.../file/our_view.
	// (Perhaps it'd be more intuitive to "append", like /path/to/a/file/our_view, but then the
	// file name would conflict with the view-containing directory.)
	//
	// Funcs that need to list the children of a fsnode.Parent should be careful: they may want to
	// set an upper limit on number of entries to read, and otherwise default to empty, to avoid
	// performance problems (resulting in bad UX) for very large directories.
	//
	// Funcs that simply look at filenames and declare derived outputs may want to place their
	// children directly under /.../file/ for convenient access. However, Funcs that are expensive,
	// for example reading some file contents, etc., may want to separate themselves under their own
	// subdirectory, like .../file/func_name/. This lets users browsing the tree "opt-in" to seeing
	// the results of the expensive computation by navigating to .../file/func_name/.
	//
	// If the input tree has any "..." that conflict with the added ones, the added ones override.
	// The originals will simply not be accessible.
	PerNodeFunc interface {
		Apply(context.Context, fsnode.T) (adds []fsnode.T, _ error)
	}
	perNodeFunc func(context.Context, fsnode.T) (adds []fsnode.T, _ error)
)

func NewPerNodeFunc(fn func(context.Context, fsnode.T) ([]fsnode.T, error)) PerNodeFunc {
	return perNodeFunc(fn)
}
func (f perNodeFunc) Apply(ctx context.Context, n fsnode.T) ([]fsnode.T, error) { return f(ctx, n) }

// ApplyPerNodeFuncs returns a new Parent that contains original's nodes plus any added by fns.
// See PerNodeFunc's for more documentation on how this works.
// Later fns's added nodes will overwrite earlier ones, if any names conflict.
func ApplyPerNodeFuncs(original fsnode.Parent, fns ...PerNodeFunc) fsnode.Parent {
	sfns := make([]PerSubtreeFunc, len(fns))
	for i, fn := range fns {
		sfns[i] = AsSubtree(fn)
	}
	return ApplyPerSubtreeFuncs(original, sfns...)
}

type converted struct{ fn PerNodeFunc }

func (c converted) Apply(ctx context.Context, n fsnode.T) (PerSubtreeFunc, []fsnode.T, error) {
	adds, err := c.fn.Apply(ctx, n)
	return c, adds, err
}

func AsSubtree(fn PerNodeFunc) PerSubtreeFunc { return converted{fn} }
